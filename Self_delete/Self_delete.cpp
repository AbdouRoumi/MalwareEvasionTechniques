#include "functions.h"

#define STREAMNEW L":R0m4"

extern  PPEB GetPEB(void);
extern  DWORD CheckDebugger(void);


BOOL CheckDebuggerPresence(void) {

	PPEB gPEB = GetPEB();

	if (CheckDebugger() != 0) {
		Warning("Debugger has been detected !!!Next time !");

		return TRUE;
	}

	info("No debugger Detected let's start!!!");
	return FALSE;

}

int SelfDelete(void) {
	HANDLE hFile = INVALID_HANDLE_VALUE;
	const wchar_t* NEWSTREAM = (const wchar_t* )STREAMNEW;
	size_t RenameSize = sizeof(FILE_RENAME_INFO) + sizeof(NEWSTREAM);
	PFILE_RENAME_INFO PFRI = NULL;
	WCHAR PathSize[MAX_PATH * 2] = { 0 };
	FILE_DISPOSITION_INFO SetDelete = { 0 };
	/*---------------Alloc Buffer For FileName-----------------*/
	PFRI =(PFILE_RENAME_INFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, RenameSize);
	if (!PFRI) {
		Warning("[HeapAlloc] failed to allocate memory ,error : 0x%lx",CustomError());
		return EXIT_FAILURE;
	}
	okay("allocated memory at [0x%p]", PFRI);
	ZeroMemory(PathSize, sizeof(PathSize));
	ZeroMemory(&SelfDelete, sizeof(FILE_DISPOSITION_INFO));
	okay("Finished");


	//-------Mark file for deletion--------------
	info("Setting up for deletion");
	SetDelete.DeleteFile = TRUE;
	okay("Finished!");


	//--------[Set New DATA STREAM BUFFER]------------
	PFRI->FileNameLength = sizeof(NEWSTREAM);
	okay("Set FILE_RENAME_INFO->FileNameLength %s", NEWSTREAM);
	RtlCopyMemory(PFRI->FileName,NEWSTREAM,sizeof(NEWSTREAM));
	okay("OverWrote FILE_RENAME_INFO->FileNameLength to %s Data stream",NEWSTREAM);
	okay("File RENAME INFO %s", PFRI->FileName);

	//----GetCurrentFileName

	info("Get Current FileName");
	if (GetModuleFileNameW(NULL, PathSize, MAX_PATH * 2) == 0) {
		Warning("[GetModuleFileName]failed to get filename,error 0x%lx", CustomError());
		return EXIT_FAILURE;
	}
	okay("finished!");


	//--------------[Get File Handle]-------------
	info("starting the renaming process");
	info("Getting file handle");
	hFile = CreateFileW(PathSize, (DELETE | SYNCHRONIZE), FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		Warning("[CreateFileW] failed to get a handle to the file ,error : 0x%lx", CustomError());
		return EXIT_FAILURE;
	}
	okay("________[hFile][0x%p]", hFile);
	info("deleting");





	//---------------[RENAME]----------

	if (!SetFileInformationByHandle(hFile, FileRenameInfo, PFRI, RenameSize)) {
		Warning("[SetFileInformationByHandle]failed to rewrite the data stream,error 0x%lx", CustomError());

	}
	okay("finished!");
	info("Closing handle to push the changer!");
	CloseHandle(hFile);
	okay("done!");

	return EXIT_SUCCESS;


		

 //-----------Real delete here -------------------

	info("getting handle on the file ");
	hFile = CreateFileW(PathSize,(DELETE|SYNCHRONIZE),FILE_SHARE_READ,NULL,OPEN_EXISTING,NULL,NULL);
	if (hFile = INVALID_HANDLE_VALUE) {
		Warning("[CreateFile]failed to get a handle to the file ,error:0x%lx", CustomError());
		return EXIT_FAILURE;

	}
	okay("\\_____[hFile\n\t\\_0x%p", hFile);
	info("Now making the deletion");

	if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &SetDelete, sizeof(SetDelete))) {
		Warning("[SetFileInfo] failed to mark file for deletion error 0x%lx", CustomError());
		return EXIT_FAILURE;
	}
	okay("Finished");
	info("Closing handle");
	CloseHandle(hFile);
	info("freeing the allocated heap buffer");
	HeapFree(GetProcessHeap(), 0, PFRI);





}
int main(void) {

	if (!CheckDebuggerPresence()) {
		info("Executing payload");
		MessageBoxW(NULL, L"Malware executes", L"Be Ready", MB_ICONEXCLAMATION | MB_HELP);
		return EXIT_SUCCESS;
	}
	info("Debugger present self Destroy");
	SelfDelete();

}